
###**进程调度的概念**

**1.定义**

* 进程调度程序决定哪个进程投入运行，何时运行以及运行多长时间。

* linux是抢占式多任务操作系统，

* linux在2.6.23内核中采用的是“完全公平调度算法”简称CFS

* 进程调度的基本单位是task_struct结构体。

**2.特点**

* cpu一个处理器在同一时刻只能运行一个进程，进程响应快，后台吞吐量大，避免进程饥饿等

* LINUX下面线程 是 lightweight process就是轻量级的进程。 一句话线程是共享了部分资源(地址空间、文件句柄、信号量等等)的进程。所以线程也按照进程的调度方式来进行调度。

* linux用户态一个进程里的多个线程是如何调度的，用户线程之间的调度由在用户空间实现的线程库实现。

**3.内核态线程（轻量级进程）和用户态进程如何区别调度：**

linux下的内核进程称为轻量级进程，每个进程下仅对应一个用户线程；用户级同一进程下的多个线程，被一一映射到具有相同ID的多个内核进程下。由于具有相同的ID，所以，这些进程可以共享文件和内存等资源。也就是说，LINUX中，ID相同的进程间调度切换时，不需要切换上下文。


**4.进程调度的目标**

* 高效性：在相同的时间下要完成更多的任务。调度程序会被频繁的执行，所以调度程序要尽可能的高效；

* 加强交互性能:在系统相当的负载下，也要保证系统的响应时间；

* 保证公平和避免饥渴；

* SMP调度：调度程序必须支持多处理系统；

* 软实时调度：系统必须有效的调用实时进程，但不保证一定满足其要求；

###**进程的分类**

**1.按进程区分**

Linux把进程区分为实时进程(real-time process)和非实时进程, 其中非实时进程进一步划分为交互式进程(interactive process)和批处理进程(batch process)。

|类型	|描述|	示例|
|:-----|:------|:------|
|交互式进程|	此类进程经常与用户进行交互, 因此需要花费很多时间等待键盘和鼠标操作. 当接受了用户的输入后, 进程必须很快被唤醒, 否则用户会感觉系统反应迟钝	|shell, 文本编辑程序和图形应用程序|
|批处理进程|	此类进程不必与用户交互, 因此经常在后台运行. 因为这样的进程不必很快相应, 因此常受到调度程序的怠慢	|程序语言的编译程序, 数据库搜索引擎以及科学计算
|实时进程|这些进程由很强的调度需要, 这样的进程绝不会被低优先级的进程阻塞. 并且他们的响应时间要尽可能的短	|视频音频应用程序, 机器人控制程序以及从物理传感器上收集数据的程序|

<br>

**2.按优先级分**

**（1）时间片**

* Linux的调度基于分时技术（time-sharing）：多个进程以“时间多路复用”方式运行，因为CPU的时间被分成“片”，给每个可运行进程分配一片，当然，单处理器在任何给定的时刻只能运行一个进程。

* 如果当前运行进程的时间片或时限（quantum）到期时，该进程还没有运行完毕，进程切换就可以发生。分时依赖于定时中断，因此，对进程是透明的。不需要在程序中插入额外的代码来保证CPU分时

**（2）进程优先级**

* 根据进程的优先级对它们进行分类。有时用复杂的算法求出进程当前的优先级，但最后的结果是相同的：每个进程都与一个值相关联，这个值表示把进程如何适当地分配
给CPU。

* 在Linux中，进程的优先级是动态的。调度程序跟踪进程正在做什么，并周期性地调整它们的优先级。在这种方式下，在较长的时间间隔内没有使用CPU的进程，通过动态地增加它们的优先级来提升它们。相应地，对于已经在CPU上运行了较长时间的进程，通过减少它们的优先级
来处罚它们

* 优先级范围
 * nice值：它的范围从-20到19，默认为0，值越大优先级越低，
 * 实时优先级：默认从0-99之间变化，值越大优先级越高，与nice相反。

###**进程调度策略**

linux内核目前实现了6种调度策略(即调度算法), 用于对不同类型的进程进行调度, 或者支持某些特殊的功能

|字段|	描述|	所在调度器类|
|:------|:-----|:------|
|SCHED_NORMAL|	（也叫SCHED_OTHER）用于普通进程，通过CFS调度器实现。SCHED_BATCH用于非交互的处理器消耗型进程。SCHED_IDLE是在系统负载很低时使用|	CFS
|SCHED_BATCH|	SCHED_NORMAL普通进程策略的分化版本。采用分时策略，根据动态优先级(可用nice()API设置），分配CPU运算资源。注意：这类进程比上述两类实时进程优先级低，换言之，在有实时进程存在时，实时进程优先调度。但针对吞吐量优化, 除了不能抢占外与常规任务一样，允许任务运行更长时间，更好地使用高速缓存，适合于成批处理的工作	|CFS|
|SCHED_IDLE	|优先级最低，在系统空闲时才跑这类进程(如利用闲散计算机资源跑地外文明搜索，蛋白质结构分析等任务，是此调度策略的适用者）	|CFS-IDLE|
|SCHED_FIFO	|先入先出调度算法（实时调度策略），相同优先级的任务先到先服务，高优先级的任务可以抢占低优先级的任务|	RT|
|SCHED_RR	|轮流调度算法（实时调度策略），后者提供 Roound-Robin 语义，采用时间片，相同优先级的任务当用完时间片会被放到队列尾部，以保证公平性，同样，高优先级的任务可以抢占低优先级的任务。不同要求的实时任务可以根据需要用sched_setscheduler() API设置策略	|RT|
|SCHED_DEADLINE|新支持的实时进程调度策略，针对突发型计算，且对延迟和完成时间高度敏感的任务适用。基于Earliest Deadline First (EDF) 调度算法|	DL|

<br>

###**普通进程的调度**

**1.定义**

每个普通进程都有它自己的静态优先权，调度程序使用静态优先权来估价系统中这个进程与
其他普通进程之间调度的程度。内核用从100（最高优先权）到139（最低优先权）的数表示
普通进程的静态优先权。注意，值越大静态优先权越低。

**2.特点**

* 新进程总是继承其父进程的静态优先权

* 静态优先权本质上决定了进程的基本时间片，即进程用完了以前的时间片时，系统分配给进程的时间片长度

* 静态优先权越高，基本时间片就越长

**3.普通进程优先权的典型值**

|说明|静态优先权|Nice值|基本时间片|交互式的值|睡眠时间的极限值|
|:------|:-----|:--------|:-----|:------|:-------|
|最高静态优先权|100| -20| 800ms |-3 |299ms|
|高静态优先权|110 |-10| 600ms| -1 |499ms|
|缺省静态优先权|120| 0 |100ms| +2| 799ms|
|低静态优先权|130| +10| 50ms| +4| 999ms|
|最低静态优先权|139| +19 |5ms |+6| 1199ms|

<br>

###**小结**

**1.系统会调用schedule()函数的情况**

* 进程从中断，异常，系统调用返回用户态的时候，系统调用 do_fork()函数

* 定时中端，当前进程的时间片用完，  do_timer()函数

* 进程状态切换的时候，进程终止，进程唤醒等，进程调用sleep() exit()等函数，唤醒进程 wake_up_process()函数

* 改变进程的调度策略：setscheduler()函数

* 系统调用礼让：sys_sched_yield()函数


未完待续，，，，，，
<br>
<br>

参考资料：

* [ Linux进程调度器的设计](http://blog.csdn.net/gatieme/article/details/51702662)
* [Linux进程调度原理](http://www.cnblogs.com/zhaoyl/archive/2012/09/04/2671156.html)

</本人才疏学浅，若有错，请指出，谢谢！>