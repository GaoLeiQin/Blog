###**进程**

####**1.进程的定义**

* 进程是一个具有一定独立功能的程序关于某次数据集合的一次运行活动，它是操作系统分配资源的基本单元。

* 进程是一个实体，由程序段、数据段和PCB（process control block）三部分组成，

####**2.进程控制块（PCB）的特点**

* PCB记录进程的属性信息，以便操作系统对进程进行控制和管理

* PCB标志着进程的存在，操作系统根据系统中是否有该进程的进程控制块PCB而知道该进程存在与否。

* 系统建立进程的同时就建立该进程的PCB，在撤销一个进程时，也就撤销其PCB，故进程的PCB对进程来说是它存在的具体的物理标志和体现。

* PCB包括进程标识信息、处理器状态信息、进程控制信息。


####**3.进程地址空间**

（1）地址空间的概念

每一个进程都有一个自己的地址空间，即进程空间或（虚空间）。进程空间的大小 只与处理机的位数有关，一个 16 位长处理机的进程空间大小为 216 ，而 32 位处理机的进程空间大小为 232 。

（2）地址空间的组成

* 文本区域（text region）：存储处理器执行的代码

* 数据区域（data region）：存储变量和进程执行期间使用的动态分配的内存

* 堆栈（stack region）：存储着活动过程中调用的指令和本地变量

####**4.进程的五种基本状态**

![这里写图片描述](http://img.blog.csdn.net/20170705133902153?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFpeWVfeGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

* 创建：进程在创建时需要申请一个空白PCB，向其中填写控制和管理进程的信息，完成资源分配。

* 就绪：进程已经准备好，已分配到所需资源，只要分配到CPU就能够立即运行

* 执行：进程处于就绪状态被调度后，进程进入执行状态

* 阻塞：正在执行的进程由于某些事件（I/O请求，申请缓存区失败）而暂时无法运行，进程受到阻塞。在满足请求时进入就绪状态等待系统调用

* 终止状态：进程结束，若出现错误或被系统终止，则进入终止状态，无法再执行。


####**5.进程的特点**

* 动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的。

* 并发性：任何进程都可以同其他进程一起并发执行。

* 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位。

* 异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。

###**线程**

####**1.线程的定义**

* 线程是指进程内的一个执行单元，也是进程内的可调度实体，作为 CPU 调度和分派的基本单位。Linux下的线程看作轻量级进程。

* 线程不拥有系统资源，只拥有在运行中必不可少的资源，如程序计数器，一组寄存器和栈，

* 一个线程可以创建和撤销另一个线程；但是它可与同一个进程的其他线程共享进程所拥有的全部资源

* 线程在执行过程中，每个独立的线程有一个程序运行的入口，顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，有应用程序提供多个线程执行控制。


####**2.线程的性质**

* 线程是进程内的一个相对独立的可执行的单元。若把进程称为任务的话，那么线程则是应用中的一个子任务的执行。

* 由于线程是被调度的基本单元，而进程不是调度单元。所以，每个进程在创建时，至少需要同时为该进程创建一个线程。即进程中至少要有一个或一个以上的线程，否则该进程无法被调度执行。

* 进程是被分给并拥有资源的基本单元。同一进程内的多个线程共享该进程的资源，但线程并不拥有资源，只是使用他们。

* 线程是操作系统中基本调度单元，因此线程中应包含有调度所需要的必要信息，且在生命周期中有状态的变化。

* 由于共享资源（数据和文件），所以线程间需要通信和同步机制，且需要时线程可以创建其他线程，但线程间不存在父子关系。


####**3.多线程(multiThread)**

（1）多线程的概念

* 在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理”。多线程是为了同步完成多项任务，不是为了提高运行效率，而是为了提高资源使用效率来提高系统的效率。线程是在同一时间需要完成多项任务的时候实现的。

（2）多线程与多进程相比的优点

* 创建和撤销线程的开销较之进程要少。创建线程时只需要建立线程控制表相应的表目，或有关队列，而创建进程时，要创建PCB表和初始化，进入有关进程队列，建立它的地址空间和所需资源等。

* CPU在线程之间开关时的开销远比进程要少得多。因开关线程都在同一地址空间内，只需要修改线程控制表或队列，不涉及地址空间和其他工作。

* 线程机制也增加了通讯的有效性。进程间的通讯往往要求内核的参与，以提供通讯机制和保护机制，而线程间的通讯是在同一进程的地址空间内，共享主存和文件，无需内核参与。




###**进程与线程的关系**

* 一个线程只能属于一个进程，而一个进程可以有多个线程，但至少有一个线程。

* 资源分配给进程，同一进程的所有线程共享该进程的所有资源。

* 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。

* 处理机分给线程，即真正在处理机上运行的是线程。

* 线程是指进程内的一个执行单元，也是进程内的可调度实体。

* 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大的提高了程序运行效率。

* 同一个进程中的多个线程之间可以并发执行.线程和进程都可并发执行。

* 进程和线程都是操作系统的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性


###**线程与进程的资源**

####**1.线程独有的资源**

* 线程ID
每个线程都有自己的线程ID，这个ID在本进程中是唯一的。进程用此来标识线程。
 
* 线程的堆栈
堆栈是保证线程独立运行所必须的。
线程函数可以调用函数，而被调用函数中又是可以层层嵌套的，所以线程必须拥有自己的函数堆栈，使得函数调用可以正常执行，不受其他线程的影响。

* 线程的优先级
由于线程需要像进程那样能够被调度，那么就必须要有可供调度使用的参数，这个参数就是线程的优先级。


* 错误返回码
由于同一个进程中有很多个线程在同时运行，可能某个线程进行系统调用 后设置了errno值，而在该线程还没有处理这个错误，另外一个线程就在此时被调度器投入运行，这样错误值就有可能被修改。 所以，不同的线程应该拥有自己的错误返回码变量。

* 寄存器组的值
由于线程间是并发运行的，每个线程有自己不同的运行线索，当从一个线程切换到另一个线程上时，必须将原有的线程的寄存器集合的状态保存，以便将来该线程在被重新切换到时能得以恢复。

* 线程的信号屏蔽码
 由于每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理。但所有的线程都共享同样的信号处理器。

####**2.线程与进程共享的资源**

* 进程代码段
* 进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)
* 进程打开的文件描述符
* 信号的处理器
* 进程的当前目录
* 进程用户ID与进程组ID。
* 地址空间
* 全局变量

###**线程与进程的区别**

**1.调度**：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。

>在传统的操作系统中，CPU调度和分派的基本单位是进程。而在引入线程的操作系统中，则把线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位，从而使传统进程的两个属性分开，线程编程轻装运行，这样可以显著地提高系统的并发性。同一进程中线程的切换不会引起进程切换，从而避免了昂贵的系统调用，但是在由一个进程中的线程切换到另一进程中的线程，依然会引起进程切换。

 
 
**2.并发性**：进程间可以并发执行，同一个进程的多个线程之间也可以并发执行

> 在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行，因而使操作系统具有更好的并发性，从而更有效地提高系统资源和系统的吞吐量。例如，在一个为引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当它由于某种原因被封锁时，便没有其他的文件服务进程来提供服务。在引入线程的操作系统中，可以在一个文件服务进程设置多个服务线程。当第一个线程等待时，文件服务进程中的第二个线程可以继续运行；当第二个线程封锁时，第三个线程可以继续执行，从而显著地提高了文件服务的质量以及系统的吞吐量。


**3.拥有资源**：进程是资源的一个独立单位，线程不拥有系统资源，但可以访问进程的资源。

> 不论是引入了线程的操作系统，还是传统的操作系统，进程都是拥有系统资源的一个独立单位，他可以拥有自己的资源。一般地说，线程自己不能拥有资源（也有一点必不可少的资源），但它可以访问其隶属进程的资源，亦即一个进程的代码段、数据段以及系统资源（如已打开的文件、I/O设备等），可供同一个进程的其他所有线程共享。进程在执行的过程中有独立的内存单元，而多个线程共享内存，从而极大地提升了程序的运行效率。


**4.独立性**： 进程有独立地址空间，而线程会共享地址空间

>  在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。这是因为为防止进程之间彼此干扰和破坏，每个进程都拥有一个独立的地址空间和其它资源，除了共享全局变量外，不允许其它进程的访问。但是同一进程中的不同线程往往是为了提高并发性以及进行相互之间的合作而创建的，它们共享进程的内存地址空间和资源，如每个线程都可以访问它们所属进程地址空间中的所有地址，如一个线程的堆栈可以被其它线程读、写，甚至完全清除。进程与进程间的代码段与数据段不一样，线程是共享进程的数据段和代码段，

**5.系统开销**：进程切换的开销大于线程

> 由于在创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统为此所付出的开销将显著地大于在创建或撤消线程时的开销。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，他们之间的同步和通信的实现变得比较容易，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

       

**6.执行过程**：线程执行开销小，但不利于资源的管理和保护，而进程恰恰相反。

> 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。


**7.支持多处理机系统**：线程适合于在SMP机器上运行，而进程则可以跨机器迁移。

>  在多处理机系统中，对于传统的进程，即单线程进程，不管有多少处理机，该进程只能运行在一个处理机上。但对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行，这无疑将加速进程的完成。因此，现代处理机OS都无一例外地引入了多线程。


<br>
<br>
本人才疏学浅，若有错，请指出，谢谢！ 
如果你有更好的建议，可以留言我们一起讨论，共同进步！ 
衷心的感谢您能耐心的读完本篇博文！

参考资料：[进程,线程 ->iOS 多线程 runloop](http://www.jianshu.com/p/2b993a4b913e)