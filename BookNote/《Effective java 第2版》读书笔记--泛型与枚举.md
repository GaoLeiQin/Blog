##第五章 泛型

<font size="4" color="blue">
**第二十三条：不要在新代码中使用原生态类型**

**1.泛型的原生态类型：**

List<E>对应的是不带任何实际参数类型的List

**2.泛型的优点：**

（1）插入元素时自带类型检查

（2）删除元素是不需要进行手工转换

（3）可以使用for-each循环，两种方法

**3.缺点**

（1）使用原生态类型，会失掉泛型在安全性和表述性方面所有的优势

（2）List与List<Object>的区别：前者可以接受List<String>，但是后者不行

（3）不确定类型的时候，应该使用无限制的通配符类型，而不是原生态类型，例如Set< ?>。 Collection< ?>不能将任何元素放入其中，因为不能确定类型。

**4.例外**

（1）类文字中必须使用原生态类型，比如List.class

（2）泛型信息会在运行时被擦除，所以在instanceof后面可以使用Set

<font size="4" color="blue">
**第二十四条：消除非受检警告：unchecked warning**

**1.如果无法消除警告，同时可以证明引起警告的代码是类型安全的。**

那么可以使用@SupressWarnings(“unchecked”)来禁止警告。
必须在每次使用这条注解的后面加注释，说明为什么要这么做

**2.应该始终在尽可能小的范围内使用SupressWarnings注解，**

永远不要在整个类上使用这条注解

**3.Return不能使用这条注解。**

应该声明一个局部变量并注解

<font size="4" color="blue">
**第二十五条：列表优先于数组**

**1.数组是协变的、具体化的，而泛型是不可变的且可以被擦除。**

**2.创建泛型数组是非法的，并非类型安全，会抛出ClassCastException异常**

但是创建List< ?>或者Map< ?,?>的数组是合法的

<font size="4" color="blue">
**第二十六条：优先考虑泛型**

**1.泛型Stack类的应用**

**2.不能创建基本类型的泛型，可以通过装箱基本类型来实现。**

<font size="4" color="blue">
**第二十七条：优先考虑泛型方法**

**1.泛型方法的特性：**

无需明确指定类型参数的值，不像调用泛型构造器一样。

（1）泛型单例工厂创建许多不可变但适合于多个不同的对象，需要编写一个静态方法，重复的给每个必要的类型参数分发对象。

（2）递归类型限制：通过某个包含该类型本身的表达式来限制类型参数。


<font size="4" color="blue">
**第二十八条：利用有限制通配符来提升API的灵活性**

**1.助记符：PECS**

 producer extends；consumer super。
 
Extends：生产数据给方法所在的实例；super：从实例（消费者）获得数据
注：所有的comparable和 comparator都是消费者。

**2.无限制的通配符与无限制的类型参数**

（1）如果类型参数只出现一次，那就应该使用通配符

（2）无限制的类型参数阻止调用者将任何非null的元素加入已有集合。

即List<?>不能放入任何参数

（3）解决方法：使用辅助方法。把泛型声明暴露给用户，在内部使用私有的实现

<font size="4" color="blue">
**第二十九条：优先考虑类型安全的异构容器**

**1.问题：**

使用类型安全的方式访问数据库的所有列，避免使用原生态

（1）解决：将Key参数化，而不是将container参数化

（2）使用Class<T>, T这样的键值对，这被称为类型安全的异构容器


##第六章 注解与枚举

<font size="4" color="blue">
**第三十条：用enum常量代替int常量**

**1.使用枚举的情况：**

需要一组固定常量，或者编译时就知道所有可能值的集合


**2.使用策略枚举的情况：**

如果多个常量共享相同的行为, 可以考虑策略枚举. 

<font size="4" color="blue">
**第三十一条： 用实例域代替序数**

**1.注意**

（1）永远不要根据枚举的序数导出与它关联的值, 而是将它保留在一个实例域中.

（2）永远不要使用ordinal()来获得序数。所有的序数都应该保存在实例域里

（3）Ordinal()用在enumSet这样的类中，如果不编写这样的类就不要使用这个函数

<font size="4" color="blue">
**第三十二条：用EnumSet代替位域**

**1.位域的不足之处：**

（1）使用方便性和类型安全方面没帮助

（2）没法把枚举常量打印或者遍历：

**2.使用EnumSet更加灵活**

<font size="4" color="blue">
**第三十三条：用EnumMap代替序数索引**

**1.注意**

（1）用EnumMap改写过的版本没有安全转换，不会出现索引问题

（2）若表示的关系是多维的，就使用EnumMap< ... ,EnumMap<...> >

（3）避免使用Enum.ordinal

<font size="4" color="blue">
**第三十四条： 使用接口模拟可伸缩的枚举**


**1.注意：**

（1）定义一个枚举类型，他实现这个接口，并用这个类型的实例代替基本类型。

（2）虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础类型对他进行模拟。


<font size="4" color="blue">
**第三十五条： 注解优先于命名模式**


**1.命名模式的缺点**

（1）拼写错误会导致失败而且没有任何提示。

（2）命名模式不能用在特定的程序元素上。

（3）命名模式不能把参数值和程序元素关联起来。

**2. 注解**

它永远不会改变被注解代码的语义, 但他们可以通过工具进行特殊的处理. 

<font size="4" color="blue">
**第三十六条：坚持使用override注解**

**1.注意**

（1）在每个方法声明中使用@override注解来覆盖超类声明。

（2）覆盖接口时也最好加注解，这样能防止添加新方法。

（3）在具体的类中，不必标注你确信覆盖了抽象方法声明的方法。

<font size="4" color="blue">
**第三十七条：用标记接口定义类型**

**1.标记接口的定义：**

（1）标记接口是没有包含方法声明的接口。例子：Serializable接口

（2）标记接口可以不改进任何方法的契约，只表示整个对象的限制条件。

**2.标记接口相对于标记注解的优势**

（1）标记接口定义的类型是由被标记类的实例实现的；标记接口没有定义这样的类型

（2）标记接口可以被更加精确的锁定

**3.标记注解的优势**

（1）可以通过默认的方法添加一个或者多个注解类型元素，给被使用的注解类型添加更多的信息

（2）它们是更大注解机制的一部分，在支持注解的框架中具有一致性


**4.适用场合**

（1）如果标记是应用在任何程序元素而非类或者接口，那么应该使用注解。

（2）如果标记永远只用于限制特殊元素的接口，那么应该使用标记接口。


<br/>
<br/>

本人才疏学浅，若有错，请指出
谢谢！
