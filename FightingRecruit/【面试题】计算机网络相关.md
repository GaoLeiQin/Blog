####**1.七层网络模型的功能，IP地址的分类？**

* 功能
 * 物理层：确定与传输媒体的接口的特性，传输比特流
 * 数据链路层：在两个相邻结点间的线路上无差错地传送以帧为单位的数据
 * 网络层：选择合适的路由，使的分组能够准确找到目的站，并交付给目的站的运输层。
 * 运输层：向上一层的进行通信的两个进程之间提供一个可靠的端到端服务
 * 会话层：解除或建立与其它节点的联系，即会话的建立和结束
 * 表示层：数据格式转换、数据加密
 * 应用层：直接为用户的应用进程提供服务

* IP地址的分类
 * A类：由1字节的网络地址和3字节主机地址组成，地址范围1.0.0.0 到126.0.0.0
 * B类：由2字节网络地址和2字节的主机地址组成，地址范围128.0.0.0到191.255.255.255
 * C类：由3字节网络地址和1字节主机地址组成，地址范围192.0.0.0到223.255.255.255
 * D类地址用于多点广播
 * E类IP地址 以“llll0”开始，为将来使用保留

* 主机字节序一般分为大端和小端两种，X86平台采用小端（低低）模式

####**2.TCP拥塞机制和流量控制**

* 利用滑动窗口实现流量控制，TCP 为每一个连接设有一个持续计时器，TCP 缓存中存放的数据达到 MSS 字节时，就组装成一个 TCP 报文段发送出去，也会有PUSH操作，计时器超时。

* 拥塞控制
慢开始：每轮cwnd乘2；拥塞避免：把cwnd控制为按线性规律增长；快重传：收到三个重复确认就应当立即重传对方尚未收到的报文段；快恢复：执行“乘法减小”算法，把cwnd 的值设置为ssthresh 减半的值，然后执行拥塞避免算法。

####**3.TCP与UDP的区别**

* UDP
 * 面向报文， 面向无连接，不提供可靠交付，不保证数据的顺序，支持一对一，一对多，多对一和多对多的交互通信，首部开销小（8字节），
 * 使用UDP的协议：DNS53、TFTP69


* TCP 
 * 面向字节流，提供面向连接的服务，全双工的可靠信道，保证数据顺序，只能是点到点通信，首部开销大（20字节）
 * 使用TCP的协议：FTP21、Telnet23、SMTP25、HTTPS443
 * 报文段首部包含源端口（2）、目的端口（2）、序号（4）、确认号（4）、数据偏移、保留位、标志位（URG、ACK、RST、SYN、FIN、PSH、CWR、ECE）、窗口（2）、检验和（2）、紧急指针（2）。

* 用UDP实现可靠传输：服务器使用UDP协议发回应答包

* udp调用connect的作用：内核仅仅把对端ip&port记录下来. 可以多次调用connect、提高效率

####**4.TCP三握手与四挥手过程？**

* 三握手
![这里写图片描述](http://img.blog.csdn.net/20170628200233128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFpeWVfeGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

* 四挥手
![这里写图片描述](http://img.blog.csdn.net/20170628200811862?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFpeWVfeGluZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

* 序号seq可以保证有序性，当序号达到最大值时（2的32次方：大约4G），可以重用，这个初始序号会随时间而改变，因此每一个连接都拥有不同的初始序列号（防止重叠），这样也保证了安全性，若序号是固定值，则很容易被伪造，从而打断TCP的正常连接

* 不是两次握手的原因：防止已失效的连接请求报文段重连，还会浪费服务器资源，因为失效的报文段会创建文件描述符从而消耗内核结构体。

* 第三次挥手中还需要ACK=1的原因：因为要给客户端通知已经收到了上一次的数据，虽然数据传送客户端的确认由内核（OS）完成。

* 为什么等待2MSL，等待时间是否可以调整？
因为要可靠地实现TCP全双工连接的终止，允许老的重复分组在网络中消逝，防止某个连接的重复报文在连接终止后出现。Windows下默认为4分钟,

* 若出现大量TIME-WAIT状态的原因及解决方法？ 
 * 原因：TIME_WAIT状态下的socket不能被回收使用.
 * 解决方法： 查看当前time_wait的数量 netstat -an | grep TIME_WAIT | wc -l
通过调整内核参数解决，vim /etc/sysctl.conf，增加或修改如下参数 ；net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies，可防范少量SYN攻击 ；开启TIME-WAIT sockets重用 （tw_reuse ）；开启TCP连接中TIME-WAIT sockets的快速回收 （tw_recycle）；减小默认的 TIMEOUT 时间 ；执行 /sbin/sysctl -p 让参数生效，
还可以将端口范围设置的很大（10万）

* 半连接队列与全连接队列是什么？
syns queue 用于保存半连接状态的请求，accept queue 用于保存全连接状态的请求。SYN攻击的解决方法：过滤网关防护（SYN代理） ，加固tcp/ip协议栈 。

* 一个客户端对外最多提供多少连接（一台服务器最多接收多少端口）？
由内核内存上限（listen所能监听的两个队列大小）和文件描述符大小（进程所能打开的文件个数上限）决定。取两个值中较小的值

* send/recv函数分别会在什么时候阻塞?
send函数（发送缓冲区）在buffer的允许发送但未发送区已满时阻塞；而recv函数（接受缓冲区）会在已确认未读取的数据为空时阻塞

* 带外数据拥有比一般数据高的优先级，用紧急模式（URG）的方法来传输带外数据的

* accept是阻塞的，否则就要等待listen的全连接队列、轮询会消耗资源。listen非阻塞是因为编程需要；两个连接是因为要维护数据转换过程，accept需要的时候就可以从listen中拿到，不用循环遍历。

####**5.域名系统？**

* 常见：.com （公司和企业） .net （网络服务机构） .org （非赢利性组织）.edu （美国专用的教育机构）

* 根域名服务器 、顶级域名服务器、权限域名服务器 、本地域名服务器，采取迭代查询的方式。

####**6.HTTP的状态码及请求报文？**

* 请求报文由请求行、请求头、（头部结束标志：空行）、请求正文组成

* 请求行中的方法：GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT

* GET与POST方法的区别
 * GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&相连， POST方法是把提交的数据放在HTTP包的Body中.多个参数之间以&分割，更安全
 * GET提交的数据大小有限制（1024k），而POST方法提交的数据没有限制.
 * GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值。
 * Get可以被浏览器缓存（默认），Post 方法不可以

* 请求报头：Accept-Language、Accept-Encoding、Accept: text等等

* 响应报文由状态行、响应头、（头部结束标志：空行）、响应实体组成

* 状态行中的状态码
 * 1xx 信息性状态码， 表示接收的请求正在处理：100 Continue ： 客户端应继续其请求
 * 2xx 成功状态码，表示请求正常处理完毕，200 OK 、201 Created、202 Accepted 
 * 3xx 重定向状态码 ，301 Moved Permanently，302 Found，
 * 4xx 客户端错误状态码 ，400 Bad Request、401 Unauthorized、403 Forbidden、404 Not Found
 * 5xx 服务端错误状态码：502 Bad Gateway（无效请求）、503 Service Unavailable、504 Gateway Time-out

* 响应报头：Accept-Ranges、Content-Length、Location等等

**7.Http与WebSocket的区别？**

* HTTP1.0 与 HTTP 1.1 的区别：1.0是短连接，而1.1是长连接；1.0中只定义了16个状态响应码，而1.1中新增了24个

* HTTP2.0的特性：二进制分帧：首部信息会被封装到Headers帧，request body封装到Data帧；多路复用：一个连接上可以有多个request，实现并行双向字节流的请求和响应；首部压缩：用首部表，不再每次请求和响应发送相同的数据；服务器推送；请求优先级：调整帧的交错和传输顺序

* Websocket是HTML5提出的一个协议规范，双向通信协议，采用异步回调的方式接受消息，当建立通信连接，可以做到持久性的连接，并行通信，通过握手建立连接，CS都能向对方发送或接受数据，全双工协议。
 *  请求报文使用：Upgrade: websocket和 Connection: Upgrade 转换到websocket协议
 * WebSocket中所有发送的数据使用帧的形式发送，一个帧包含一个帧类型的标识码，一个负载长度，和负载。
 * WebSocket使用HTTP来建立连接，但是定义了一系列新的header域，这些域在HTTP中并不会使用
 * WebSocket的连接不能通过中间人来转发，它必须是一个直接连接
 * WebSocket在建立握手连接时，数据是通过http协议传输的，但在建立连接之后，真正的数据传输阶段是不需要http协议参与的
 * websocket传输的数据是二进制流，是以帧为单位的，http传输的是明文传输，是字符串传输，WebSocket的数据帧有序。
 * websocket的持久连接：只需建立一次Request/Response消息对，之后都是TCP连接，避免了需要多次建立Request/Response消息对而产生的冗余头部信息

####**8.HTTP与HTTPS的区别？**

* HTTP通信使用明文， 内容可能会被窃听，不验证通信方的身份， 因此有可能遭遇伪装，无法证明报文的完整性， 所以有可能已遭篡改，无法阻止海量请求下的DoS 攻击。

* HTTPS在HTTP协议基础上增加了TLS/SSL加密传送信息，使用443端口，

* TLS使用HMAC算法，更严密的警报
指纹是在证书信息后面加上一段内容（指纹算法），保证信息没有被修改过。把前面的证书内容用指纹算法计算后与指纹内容比对，由于指纹内容是由证书机构唯一的私钥加密的，比对成功则是安全的。

* HTTPS加密解密过程：客户端发起HTTPS请求-->服务端用CA配置-->传送证书（公匙）-->客户端解析证书（由TLS验证后生成一个随机值加密）-->传送加密信息（随机值）-->服务段解密信息（用私钥解密随机值，把内容通过该值进行对称加密）-->传输加密后的信息-->客户端解密信息（用之前生成的私钥解密）


* SSL/TLS协议提供的服务：
 * 认证用户和服务器，确保数据发送到正确的客户机和服务器；
 * 加密数据以防止数据中途被窃取；
 * 维护数据的完整性，确保数据在传输过程中不被改变


####**9.从输入 URL 到显示页面发生了什么？**

* 输入网址， 浏览器分析超链指向页面的 URL
* 浏览器向 DNS 请求解析出域名的 IP 地址　
* 浏览器向服务器发送一个 HTTP 请求（建立 TCP 连接）
* 服务器的永久重定向响应
* 服务器处理请求
* 服务器返回一个 HTTP 响应（TCP 连接释放）
* 浏览器发送请求获取嵌入在 HTML 中的资源显示 HTML


<br>
<br>
本人才疏学浅，若有错，请指出，谢谢！ 
如果你有更好的建议，可以留言我们一起讨论，共同进步！ 
衷心的感谢您能耐心的读完本篇博文！